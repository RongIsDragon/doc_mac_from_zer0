# 操作系统接口 - `os`模块

此模块可以让我们“可移植”的使用平台相关函数。如果你只是想要读写文件，可以使用`__builtins__['open']`函数；如果你想要操作文件系统路径，可以使用`os.path`模块；如果你想要在命令行模式下读取所有指定文件的内容，可以使用`fileinput`模块；如果你想要创建临时文件及文件夹，可以使用`tempfile`模块；如果需要文件操作的高级函数，可以使用`shutil`模块。

留意此模块中函数的共性：

* Python设计这个边平台相关内建模块的初衷，是为了让同一个功能在任何支持的平台上，拥有相同的接口。比如，`os.stat(path)`函数在所有支持的平台上都以相同的形式返回*path*的状态（这个返回状态恰巧来自POSIX系统）；
* `os`模块也支持一些平台特有的属性，不过，使用这些平台特有属性可能会影响到代码的可移植性；
* 模块中接受路径或文件名做参数的函数都支持`str`和`bytes`两种类型。如果该函数返回路径或文件名，返回值的类型会与参数类型相同；
* 诸如“支持：Unix”的标记表示在Unix上更常见，而并不是说仅Unix提供支持；
* 如果不特意指明，“支持：Unix”同样使用于Unix内核的Mac OS X；

注意：模块中的函数在遇到：不合法或不可访问的路径或文件名，参数正确但系统不支持时会抛出`OSError`。

### exception os.error

内建异常`OSError`的别名。

### os.name

导入此模块时基于的操作系统名称，现在注册的名称有'posix', 'nt', 'mac', 'ce', 'java'。

`sys.platform`的结果更具体，`os.uname()`的结果还包含操作系统版本等信息。

要得到更详细的系统信息，可以使用`platform`模块。

## 文件名、命令行参数、环境变量

Python中使用`str`表示文件名、命令行参数、环境变量。对于模型操作环境，有必要将这些字符串转为`bytes`再传给操作系统。Python使用文件系统默认编码做这种转换（见`sys.getfilesystemencoding()`）。

Python3.1后：在一些环境中，使用文件系统编码可能会产生错误。所以Python使用了`surrogateescape`控制编码异常，也就是把不可被解码的`bytes`在解码时记为Unicode字符“U+DCxx”，于是这种字符在编码时会被重新译为原始`bytes`。

文件系统默认编码至少要做到能够正确解码每个数值小于128的`bytes`，否则API可能会抛出`UnicodeErrors`异常。

## 进程参数

